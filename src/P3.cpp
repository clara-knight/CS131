#include <cstdint>
#include <format>
#include <immintrin.h>
#include <iostream>
#include <random>
#include <string>

__m256i b_trial(const __m256d p_v, const __m256d random_doubles,
                const __m256i ones_int_vec) {
  __m256d trial_results_d = _mm256_cmp_pd(random_doubles, p_v, _CMP_LT_OQ);
  __m256i trial_results = _mm256_castpd_si256(trial_results_d);
  trial_results = _mm256_and_si256(trial_results, ones_int_vec);

  return trial_results;
}

// Functions to generate random numbers using AVX2
__m256i initialize_xorshiftstate_avx2(std::mt19937_64);
__m256i xorshift128plus_avx2(__m256i &, __m256i &);
__m256d normalize_xorshift128_ints(const __m256i);
__m256d get_random_doubles(__m256i &, __m256i &, const __m256i, const __m256d);
uint64_t extract_trials_sum(const __m256i);

int main(int argc, char *argv[]) {
  double p = std::stof(argv[1]);
  uint64_t n = 0xFFFFFF;
  __m256d p_v = _mm256_set1_pd(p);

  std::random_device rd;
  std::mt19937_64 m_rng(rd());

  // Set up the xorshift128+ RNG
  __m256i state0 = initialize_xorshiftstate_avx2(m_rng);
  __m256i state1 = initialize_xorshiftstate_avx2(m_rng);
  const __m256i exponent_mask = _mm256_set1_epi64x(0x3FF0000000000000ULL);
  const __m256d ones_float = _mm256_set1_pd(1.0);

  __m256i trials_sum = _mm256_setzero_si256();
  __m256i ones_int = _mm256_set1_epi64x(1);

  for (int j = 0; j < n; ++j) {
    trials_sum = _mm256_add_epi64(
        trials_sum,
        b_trial(p_v,
                get_random_doubles(state0, state1, exponent_mask, ones_float),
                ones_int));
  }

  uint64_t trials_sum_int = extract_trials_sum(trials_sum);

  std::cout << std::format("Observed p = {}",
                           trials_sum_int / static_cast<float>(n * 4));
  return 0;
}

// We initialize the state for the xorshift128+ rng
__m256i initialize_xorshiftstate_avx2(std::mt19937_64 m_rng) {
  return _mm256_set_epi64x(m_rng(), m_rng(), m_rng(), m_rng());
}

// We generate four random ints using xorshift128+
__m256i xorshift128plus_avx2(__m256i &state0, __m256i &state1) {
  __m256i s1 = state0;
  const __m256i s0 = state1;
  state0 = s0;
  s1 = _mm256_xor_si256(s1, _mm256_slli_epi64(s1, 23));
  state1 = _mm256_xor_si256(
      _mm256_xor_si256(_mm256_xor_si256(s1, s0), _mm256_srli_epi64(s1, 18)),
      _mm256_srli_epi64(s0, 5));
  return _mm256_add_epi64(state1, s0);
}

// We normalize the ints generated by xorshift128+ into floats in [0, 1)
__m256d normalize_xorshift128_ints(__m256i xorshift_ints,
                                   const __m256i exponent_mask,
                                   const __m256d ones) {
  __m256i top_52_bits = _mm256_srli_epi64(xorshift_ints, 12);
  __m256i double_bits = _mm256_or_si256(top_52_bits, exponent_mask);
  __m256d doubles_in_range_1_to_2 = _mm256_castsi256_pd(double_bits);
  return _mm256_sub_pd(doubles_in_range_1_to_2, ones);
}

__m256d get_random_doubles(__m256i &state0, __m256i &state1,
                           const __m256i exp_mask, const __m256d ones_d) {
  return normalize_xorshift128_ints(xorshift128plus_avx2(state0, state1),
                                    exp_mask, ones_d);
}

uint64_t extract_trials_sum(const __m256i trials_sum) {
  __m128i trial_sum_128 = _mm_add_epi64(_mm256_extracti128_si256(trials_sum, 1),
                                        _mm256_castsi256_si128(trials_sum));
  return _mm_extract_epi64(trial_sum_128, 1) + _mm_cvtsi128_si64(trial_sum_128);
}
